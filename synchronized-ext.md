## 共享数据与锁
Java虚拟机的运行时数据区中的堆和方法区是所有线程共享的区域，如果多个线程需要同时使用共享的对象或类变量，则必须要正确协调它们对数据的访问。否则，程序将具有不可预测的行为。为了协调多个线程之间的共享数据访问，Java虚拟机将锁与每个对象或类关联起来。锁就像一种特权，在任何时候只有一个线程可以“拥有”它。如果一个线程想要锁定一个特定的对象或类，它会请求JVM，在线程向JVM请求锁之后(如果锁未被持有可能很快，如果锁被持有也可能稍后，也可能永远不会)，JVM将锁提供给线程。当线程不再需要锁时，它将锁返回给JVM。

## 对象锁与类锁
对象锁即类实例对象的锁，具体稍后详细分析。

类锁实际上是作为对象锁实现的。当JVM加载类文件时，它会创建类java.lang.Class的实例。当锁定一个类时，实际上锁定了那个类的类对象。

## Monitors
JVM与monitors一起使用锁。一个monitor基本上就是一个保护器，它监视受保护的代码，确保每次只被一个线程执行。monitor的具体实现因JVM不同而不同，在HotSpot虚拟机中，monitor是由ObjectMonitor实现的，这里暂不深入分析。每个monitor都与一个对象相关联，当一个线程执行到一个monitor监视下的代码块中的第一个指令时，该线程必须在引用的对象上获得一个锁。线程在获得锁之前不允许执行后续代码，一旦获得锁，线程就可以执行受保护的代码块。当线程执行代码块结束时，无论它如何结束(正常执行结束或异常退出)，它都会释放关联对象上的锁。

一个线程可以多次锁定同一个对象。对于每个对象，JVM维护对象被锁定的次数的计数。未加锁的对象的计数为零。当线程第一次获得锁时，计数将增加到1。每次线程获取同一个对象上的锁时，都会增加一个计数。每次线程释放锁时，计数将被递减。当计数达到0时，锁被释放，此时其它线程可以继续请求获取锁。

## Java对象与monitor
Java对象在内存中存储的布局分为3块区域：对象头、实例数据和对齐填充。对象头包含两部分，第一部分包含对象的HashCode、分代年龄、锁标志位等数据，另一部分是类型指针，JVM通过这个指针来确定这个对象是哪个类的实例。
